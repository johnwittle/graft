#!/usr/bin/env python3
"""
Convert a Claude Code session (JSONL) to graft conversation format (JSON).

Usage: claude-session-to-graft <input.jsonl> [output.json]

If output is not specified, prints to stdout.
The resulting JSON can be placed in ~/.graft/conversations/ and loaded with graft.
"""

import json
import sys
from datetime import datetime
from pathlib import Path


def parse_jsonl(filepath):
    """Parse JSONL file, yielding each parsed line."""
    with open(filepath, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    yield json.loads(line)
                except json.JSONDecodeError as e:
                    print(f"Warning: skipping malformed line: {e}", file=sys.stderr)


def extract_messages(events):
    """
    Extract user/assistant messages from Claude Code events.
    
    Claude Code streams assistant messages as multiple events with the same message ID,
    each containing different content blocks. We need to accumulate all blocks for each
    message ID, then emit them in the order they appear.
    """
    # First pass: collect all events and group assistant content by message ID
    assistant_content_by_id = {}  # msg_id -> list of content blocks
    assistant_order = []  # track order of first appearance of each msg_id
    
    ordered_events = []  # (event_type, data) tuples in order
    
    for event in events:
        event_type = event.get('type')
        uuid = event.get('uuid')
        
        if event_type == 'user':
            msg = event.get('message', {})
            content = msg.get('content', '')
            if content:
                # Check if this is a tool_result (list with tool_result blocks)
                if isinstance(content, list) and any(
                    isinstance(b, dict) and b.get('type') == 'tool_result' 
                    for b in content
                ):
                    ordered_events.append(('tool_result', content, uuid))
                else:
                    ordered_events.append(('user', content, uuid))
                    
        elif event_type == 'assistant':
            msg = event.get('message', {})
            msg_id = msg.get('id')
            content_blocks = msg.get('content', [])
            
            if msg_id and content_blocks:
                if msg_id not in assistant_content_by_id:
                    assistant_content_by_id[msg_id] = []
                    assistant_order.append(msg_id)
                    ordered_events.append(('assistant', msg_id, uuid))
                
                # Accumulate content blocks
                for block in content_blocks:
                    # Check if we already have this block (by comparing structure)
                    is_duplicate = False
                    for existing in assistant_content_by_id[msg_id]:
                        if block == existing:
                            is_duplicate = True
                            break
                        # Also check for same tool_use id
                        if (block.get('type') == 'tool_use' and 
                            existing.get('type') == 'tool_use' and
                            block.get('id') == existing.get('id')):
                            is_duplicate = True
                            break
                    if not is_duplicate:
                        assistant_content_by_id[msg_id].append(block)
    
    # Second pass: build messages in order
    messages = []
    
    for event_type, data, uuid in ordered_events:
        if event_type == 'user':
            content = data
            if isinstance(content, str):
                content = content.rstrip('\n')
            messages.append({'role': 'user', 'content': content})
            
        elif event_type == 'assistant':
            msg_id = data
            content_blocks = assistant_content_by_id.get(msg_id, [])
            if content_blocks:
                # Simplify if it's just a single text block
                if (len(content_blocks) == 1 and 
                    isinstance(content_blocks[0], dict) and 
                    content_blocks[0].get('type') == 'text'):
                    content = content_blocks[0].get('text', '').rstrip('\n')
                else:
                    content = content_blocks
                messages.append({'role': 'assistant', 'content': content})
                
        elif event_type == 'tool_result':
            messages.append({'role': 'user', 'content': data})
    
    return messages


def extract_metadata(events):
    """Extract session metadata from events."""
    metadata = {
        'session_id': None,
        'cwd': None,
        'version': None,
        'model': None,
        'start_time': None,
        'end_time': None,
    }
    
    for event in events:
        if event.get('sessionId') and not metadata['session_id']:
            metadata['session_id'] = event['sessionId']
        if event.get('cwd') and not metadata['cwd']:
            metadata['cwd'] = event['cwd']
        if event.get('version') and not metadata['version']:
            metadata['version'] = event['version']
        if event.get('timestamp'):
            ts = event['timestamp']
            if not metadata['start_time']:
                metadata['start_time'] = ts
            metadata['end_time'] = ts
        
        # Get model from assistant messages
        msg = event.get('message', {})
        if msg.get('model') and not metadata['model']:
            metadata['model'] = msg['model']
    
    return metadata


def convert_session(input_path, output_path=None):
    """Convert Claude Code session to graft format."""
    events = list(parse_jsonl(input_path))
    
    if not events:
        print("Error: no events found in session file", file=sys.stderr)
        return False
    
    messages = extract_messages(events)
    metadata = extract_metadata(events)
    
    # Build graft conversation structure
    now = datetime.now().isoformat()
    name = Path(input_path).stem
    
    # Clean up name if it's a UUID or archive name
    if '_' in name:
        # Archive format: 20260107-123456-12345_uuid.jsonl
        parts = name.split('_', 1)
        name = f"claude-sub-{parts[0]}"
    
    graft_conv = {
        'name': name,
        'created': metadata.get('start_time', now),
        'modified': metadata.get('end_time', now),
        'model': metadata.get('model', 'claude-sonnet-4-5-20250929'),
        'system_prompt': f"[Imported from Claude Code session]\n[Original CWD: {metadata.get('cwd', 'unknown')}]\n[Session ID: {metadata.get('session_id', 'unknown')}]",
        'messages': messages,
        'web_search': False,
        'tools_path': None,
        'shell_enabled': True  # Claude Code sessions typically had shell access
    }
    
    output_json = json.dumps(graft_conv, indent=2)
    
    if output_path:
        with open(output_path, 'w') as f:
            f.write(output_json)
        print(f"Converted {len(messages)} messages to {output_path}", file=sys.stderr)
    else:
        print(output_json)
    
    return True


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    input_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not Path(input_path).exists():
        print(f"Error: {input_path} not found", file=sys.stderr)
        sys.exit(1)
    
    success = convert_session(input_path, output_path)
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
