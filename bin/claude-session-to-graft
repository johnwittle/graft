#!/usr/bin/env python3
"""
Convert a Claude Code session (JSONL) to graft conversation format (JSON).

Usage: claude-session-to-graft <input.jsonl> [output.json]

If output is not specified, prints to stdout.
The resulting JSON can be placed in ~/.graft/conversations/ and loaded with graft.
"""

import json
import sys
from datetime import datetime
from pathlib import Path


def parse_jsonl(filepath):
    """Parse JSONL file, yielding each parsed line."""
    with open(filepath, 'r') as f:
        for line in f:
            line = line.strip()
            if line:
                try:
                    yield json.loads(line)
                except json.JSONDecodeError as e:
                    print(f"Warning: skipping malformed line: {e}", file=sys.stderr)


def normalize_content(content):
    """Normalize content to string or list format."""
    if isinstance(content, str):
        return content.rstrip('\n')
    elif isinstance(content, list):
        # If it's a single text block, simplify to string
        if len(content) == 1 and isinstance(content[0], dict) and content[0].get('type') == 'text':
            return content[0].get('text', '').rstrip('\n')
        # Otherwise keep as list
        return content
    else:
        return str(content)


def extract_messages(events):
    """Extract user/assistant messages from Claude Code events."""
    messages = []
    seen_assistant_ids = set()  # Claude Code sends multiple events per response
    
    for event in events:
        event_type = event.get('type')
        
        if event_type == 'user':
            msg = event.get('message', {})
            content = msg.get('content', '')
            if content:
                messages.append({
                    'role': 'user',
                    'content': normalize_content(content)
                })
                
        elif event_type == 'assistant':
            msg = event.get('message', {})
            msg_id = msg.get('id')
            
            # Skip if we've already processed this message
            # (Claude Code sends partial updates as separate events)
            if msg_id and msg_id in seen_assistant_ids:
                # Update the last message with this ID if content is longer
                content_blocks = msg.get('content', [])
                if content_blocks and messages:
                    for i in range(len(messages) - 1, -1, -1):
                        if messages[i].get('_msg_id') == msg_id:
                            new_content = normalize_content(content_blocks)
                            old_content = messages[i].get('content', '')
                            # Keep the longer/more complete version
                            if isinstance(new_content, str) and isinstance(old_content, str):
                                if len(new_content) > len(old_content):
                                    messages[i]['content'] = new_content
                            elif isinstance(new_content, list):
                                messages[i]['content'] = new_content
                            break
                continue
            
            content_blocks = msg.get('content', [])
            if content_blocks:
                message_entry = {
                    'role': 'assistant',
                    'content': normalize_content(content_blocks)
                }
                if msg_id:
                    message_entry['_msg_id'] = msg_id
                    seen_assistant_ids.add(msg_id)
                messages.append(message_entry)
        
        elif event_type == 'tool_result':
            # Tool results from user side
            msg = event.get('message', {})
            content = msg.get('content', [])
            tool_use_id = None
            
            # Find tool_use_id
            if isinstance(content, list):
                for block in content:
                    if isinstance(block, dict) and block.get('type') == 'tool_result':
                        tool_use_id = block.get('tool_use_id')
                        break
            
            if content:
                messages.append({
                    'role': 'user',
                    'content': content if isinstance(content, list) else [{'type': 'tool_result', 'content': str(content)}]
                })
    
    # Clean up internal tracking fields
    for msg in messages:
        msg.pop('_msg_id', None)
    
    return messages


def extract_metadata(events):
    """Extract session metadata from events."""
    metadata = {
        'session_id': None,
        'cwd': None,
        'version': None,
        'model': None,
        'start_time': None,
        'end_time': None,
    }
    
    for event in events:
        if event.get('sessionId') and not metadata['session_id']:
            metadata['session_id'] = event['sessionId']
        if event.get('cwd') and not metadata['cwd']:
            metadata['cwd'] = event['cwd']
        if event.get('version') and not metadata['version']:
            metadata['version'] = event['version']
        if event.get('timestamp'):
            ts = event['timestamp']
            if not metadata['start_time']:
                metadata['start_time'] = ts
            metadata['end_time'] = ts
        
        # Get model from assistant messages
        msg = event.get('message', {})
        if msg.get('model') and not metadata['model']:
            metadata['model'] = msg['model']
    
    return metadata


def convert_session(input_path, output_path=None):
    """Convert Claude Code session to graft format."""
    events = list(parse_jsonl(input_path))
    
    if not events:
        print("Error: no events found in session file", file=sys.stderr)
        return False
    
    messages = extract_messages(events)
    metadata = extract_metadata(events)
    
    # Build graft conversation structure
    now = datetime.now().isoformat()
    name = Path(input_path).stem
    
    # Clean up name if it's a UUID or archive name
    if '_' in name:
        # Archive format: 20260107-123456-12345_uuid.jsonl
        parts = name.split('_', 1)
        name = f"claude-sub-{parts[0]}"
    
    graft_conv = {
        'name': name,
        'created': metadata.get('start_time', now),
        'modified': metadata.get('end_time', now),
        'model': metadata.get('model', 'claude-sonnet-4-5-20250929'),
        'system_prompt': f"[Imported from Claude Code session]\n[Original CWD: {metadata.get('cwd', 'unknown')}]\n[Session ID: {metadata.get('session_id', 'unknown')}]",
        'messages': messages,
        'web_search': False,
        'tools_path': None,
        'shell_enabled': True  # Claude Code sessions typically had shell access
    }
    
    output_json = json.dumps(graft_conv, indent=2)
    
    if output_path:
        with open(output_path, 'w') as f:
            f.write(output_json)
        print(f"Converted {len(messages)} messages to {output_path}", file=sys.stderr)
    else:
        print(output_json)
    
    return True


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    input_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    if not Path(input_path).exists():
        print(f"Error: {input_path} not found", file=sys.stderr)
        sys.exit(1)
    
    success = convert_session(input_path, output_path)
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
