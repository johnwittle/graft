#!/bin/bash
# claude-sub: Non-interactive Claude Code wrapper with automatic session archiving
#
# Usage: claude-sub <task-description> [prompt]
#        claude-sub <task-description> --stdin  (read prompt from stdin)
#
# Designed for use by graft Claudes calling Claude Code as a subagent.
# Sessions are archived to ~/.claude-archive/ for later import into graft.
#
# Examples:
#   claude-sub "fix login bug" "Find and fix the authentication issue in auth.py"
#   echo "Refactor the database module" | claude-sub "db refactor" --stdin

set -e

ARCHIVE_DIR="$HOME/.claude-archive"
SESSIONS_LOG="$ARCHIVE_DIR/sessions.log"
RAW_DIR="$ARCHIVE_DIR/raw"

# Ensure archive directories exist
mkdir -p "$RAW_DIR"

# Generate session ID
SESSION_ID=$(date +%Y%m%d-%H%M%S)-$$

# Parse arguments
TASK_DESC=""
PROMPT=""
USE_STDIN=false
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --stdin)
            USE_STDIN=true
            shift
            ;;
        --*)
            # Pass through other flags to claude
            EXTRA_ARGS+=("$1")
            shift
            ;;
        *)
            if [ -z "$TASK_DESC" ]; then
                TASK_DESC="$1"
            elif [ -z "$PROMPT" ]; then
                PROMPT="$1"
            else
                # Additional args get appended to prompt
                PROMPT="$PROMPT $1"
            fi
            shift
            ;;
    esac
done

# Read from stdin if requested
if [ "$USE_STDIN" = true ]; then
    PROMPT=$(cat)
fi

# Validate we have what we need
if [ -z "$TASK_DESC" ]; then
    echo "Usage: claude-sub <task-description> [prompt]" >&2
    echo "       claude-sub <task-description> --stdin" >&2
    exit 1
fi

if [ -z "$PROMPT" ]; then
    echo "Error: No prompt provided" >&2
    exit 1
fi

# Record session start
{
    echo "[$SESSION_ID] START $(date -Iseconds)"
    echo "[$SESSION_ID] TASK: $TASK_DESC"
    echo "[$SESSION_ID] CWD: $(pwd)"
    echo "[$SESSION_ID] PROMPT: ${PROMPT:0:200}..."
} >> "$SESSIONS_LOG"

# Capture the project directory Claude Code will use
PROJECT_DIR_MANGLED=$(pwd | sed 's|^/||; s|/|-|g')
if [ -z "$PROJECT_DIR_MANGLED" ]; then
    PROJECT_DIR_MANGLED="-"
fi
CLAUDE_PROJECT_DIR="$HOME/.claude/projects/-$PROJECT_DIR_MANGLED"

# Get list of existing session files before running
EXISTING_SESSIONS=""
if [ -d "$CLAUDE_PROJECT_DIR" ]; then
    EXISTING_SESSIONS=$(ls "$CLAUDE_PROJECT_DIR"/*.jsonl 2>/dev/null | sort)
fi

# Run Claude Code non-interactively
# Unset API key to force Claude Code to use OAuth (Max plan) instead
unset ANTHROPIC_API_KEY
# --print: non-interactive mode, print response and exit
# --dangerously-skip-permissions: skip all permission dialogs (safe in supervised context)
# --output-format json: structured output for easier parsing
claude --print --dangerously-skip-permissions --output-format json "${EXTRA_ARGS[@]}" "$PROMPT"
EXIT_CODE=$?

# Find new session files
NEW_SESSIONS=""
if [ -d "$CLAUDE_PROJECT_DIR" ]; then
    CURRENT_SESSIONS=$(ls "$CLAUDE_PROJECT_DIR"/*.jsonl 2>/dev/null | sort)
    NEW_SESSIONS=$(comm -13 <(echo "$EXISTING_SESSIONS") <(echo "$CURRENT_SESSIONS") 2>/dev/null)
fi

# Archive new sessions
if [ -n "$NEW_SESSIONS" ]; then
    for SESSION_FILE in $NEW_SESSIONS; do
        BASENAME=$(basename "$SESSION_FILE")
        ARCHIVE_NAME="${SESSION_ID}_${BASENAME}"
        cp "$SESSION_FILE" "$RAW_DIR/$ARCHIVE_NAME"
        echo "[$SESSION_ID] ARCHIVED: $ARCHIVE_NAME" >> "$SESSIONS_LOG"
    done
else
    echo "[$SESSION_ID] NO_SESSION_FILE" >> "$SESSIONS_LOG"
fi

# Record session end
{
    echo "[$SESSION_ID] END $(date -Iseconds) exit=$EXIT_CODE"
    echo ""
} >> "$SESSIONS_LOG"

exit $EXIT_CODE
