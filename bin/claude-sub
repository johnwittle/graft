#!/bin/bash
# claude-sub: Non-interactive Claude Code wrapper with automatic session archiving
#
# Usage: claude-sub <task-description> [prompt]
#        claude-sub <task-description> --stdin       (read prompt from stdin)
#        claude-sub <task-description> --async       (run in background)
#        claude-sub --status [task-id]               (check async task status)
#        claude-sub --result [task-id]               (get async task result)
#
# Designed for use by graft Claudes calling Claude Code as a subagent.
# Sessions are archived to ~/.claude-archive/ for later import into graft.
#
# Examples:
#   claude-sub "fix login bug" "Find and fix the authentication issue in auth.py"
#   echo "Refactor the database module" | claude-sub "db refactor" --stdin
#   claude-sub "investigate logs" "Check why the server is slow" --async
#   claude-sub --status  # check latest async task
#   claude-sub --result  # get latest async task output

set -e

# Show help if no args or --help
if [ $# -eq 0 ] || [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    cat << 'HELPEOF'
claude-sub: Run Claude Code as a subagent with session archiving

USAGE:
  claude-sub <description> <prompt>           Synchronous (30s timeout from graft)
  claude-sub <description> <prompt> --async   Background task, no timeout
  claude-sub <description> --stdin            Read prompt from stdin
  claude-sub --status [task-id]               Check async task status
  claude-sub --result [task-id]               Get async task output

EXAMPLES:
  # Quick synchronous task
  claude-sub "fix typo" "Fix the typo in README.md line 42"

  # Complex async investigation  
  claude-sub "debug auth" "Find why login fails for SSO users" --async
  claude-sub --status    # check progress
  claude-sub --result    # get findings

  # Bulk operation with stdin
  echo "Refactor all error handling to use Result types" | claude-sub "refactor" --stdin --async

NOTES:
  - Uses Claude Code with Max plan (not API credits)
  - Sessions archived to ~/.claude-archive/ for later import to graft
  - Results stored in ~/.claude-sub-results/
  - Use --async for tasks that may take > 30 seconds
HELPEOF
    exit 0
fi

ARCHIVE_DIR="$HOME/.claude-archive"
SESSIONS_LOG="$ARCHIVE_DIR/sessions.log"
RAW_DIR="$ARCHIVE_DIR/raw"
RESULTS_DIR="$HOME/.claude-sub-results"

# Ensure directories exist
mkdir -p "$RAW_DIR" "$RESULTS_DIR"

# Handle --status command
if [ "$1" = "--status" ]; then
    TASK_ID="${2:-latest}"
    if [ "$TASK_ID" = "latest" ]; then
        TASK_ID=$(ls -t "$RESULTS_DIR"/*.status 2>/dev/null | head -1 | xargs -r basename | sed 's/\.status$//')
    fi
    if [ -z "$TASK_ID" ] || [ ! -f "$RESULTS_DIR/$TASK_ID.status" ]; then
        echo "No async tasks found"
        exit 1
    fi
    cat "$RESULTS_DIR/$TASK_ID.status"
    exit 0
fi

# Handle --result command
if [ "$1" = "--result" ]; then
    TASK_ID="${2:-latest}"
    if [ "$TASK_ID" = "latest" ]; then
        TASK_ID=$(ls -t "$RESULTS_DIR"/*.status 2>/dev/null | head -1 | xargs -r basename | sed 's/\.status$//')
    fi
    if [ -z "$TASK_ID" ] || [ ! -f "$RESULTS_DIR/$TASK_ID.status" ]; then
        echo "No async tasks found"
        exit 1
    fi
    STATUS=$(cat "$RESULTS_DIR/$TASK_ID.status")
    if [ "$STATUS" = "running" ]; then
        echo "Task $TASK_ID is still running"
        exit 1
    fi
    if [ -f "$RESULTS_DIR/$TASK_ID.out" ]; then
        cat "$RESULTS_DIR/$TASK_ID.out"
    else
        echo "No output file found for $TASK_ID"
        exit 1
    fi
    exit 0
fi

# Generate session ID
SESSION_ID=$(date +%Y%m%d-%H%M%S)-$$

# Parse arguments
TASK_DESC=""
PROMPT=""
USE_STDIN=false
ASYNC_MODE=false
EXTRA_ARGS=()

while [[ $# -gt 0 ]]; do
    case "$1" in
        --stdin)
            USE_STDIN=true
            shift
            ;;
        --async|--background)
            ASYNC_MODE=true
            shift
            ;;
        --*)
            # Pass through other flags to claude
            EXTRA_ARGS+=("$1")
            shift
            ;;
        *)
            if [ -z "$TASK_DESC" ]; then
                TASK_DESC="$1"
            elif [ -z "$PROMPT" ]; then
                PROMPT="$1"
            else
                # Additional args get appended to prompt
                PROMPT="$PROMPT $1"
            fi
            shift
            ;;
    esac
done

# Read from stdin if requested
if [ "$USE_STDIN" = true ]; then
    PROMPT=$(cat)
fi

# Validate we have what we need
if [ -z "$TASK_DESC" ]; then
    echo "Usage: claude-sub <task-description> [prompt]" >&2
    echo "       claude-sub <task-description> --stdin" >&2
    echo "       claude-sub <task-description> --async" >&2
    echo "       claude-sub --status [task-id]" >&2
    echo "       claude-sub --result [task-id]" >&2
    exit 1
fi

if [ -z "$PROMPT" ]; then
    echo "Error: No prompt provided" >&2
    exit 1
fi

# Record session start
{
    echo "[$SESSION_ID] START $(date -Iseconds)"
    echo "[$SESSION_ID] TASK: $TASK_DESC"
    echo "[$SESSION_ID] CWD: $(pwd)"
    echo "[$SESSION_ID] ASYNC: $ASYNC_MODE"
    echo "[$SESSION_ID] PROMPT: ${PROMPT:0:200}..."
} >> "$SESSIONS_LOG"

# Capture the project directory Claude Code will use
PROJECT_DIR_MANGLED=$(pwd | sed 's|^/||; s|/|-|g')
if [ -z "$PROJECT_DIR_MANGLED" ]; then
    PROJECT_DIR_MANGLED="-"
fi
CLAUDE_PROJECT_DIR="$HOME/.claude/projects/-$PROJECT_DIR_MANGLED"

# Get list of existing session files before running
EXISTING_SESSIONS=""
if [ -d "$CLAUDE_PROJECT_DIR" ]; then
    EXISTING_SESSIONS=$(ls "$CLAUDE_PROJECT_DIR"/*.jsonl 2>/dev/null | sort)
fi

# Function to run claude and archive results
run_claude() {
    # Unset API key to force Claude Code to use OAuth (Max plan) instead
    unset ANTHROPIC_API_KEY
    
    # Run Claude Code non-interactively
    # --print: non-interactive mode, print response and exit
    # --dangerously-skip-permissions: skip all permission dialogs (safe in supervised context)
    # --output-format json: structured output for easier parsing
    claude --print --dangerously-skip-permissions --output-format json "${EXTRA_ARGS[@]}" "$PROMPT"
    EXIT_CODE=$?
    
    # Find new session files
    NEW_SESSIONS=""
    if [ -d "$CLAUDE_PROJECT_DIR" ]; then
        CURRENT_SESSIONS=$(ls "$CLAUDE_PROJECT_DIR"/*.jsonl 2>/dev/null | sort)
        NEW_SESSIONS=$(comm -13 <(echo "$EXISTING_SESSIONS") <(echo "$CURRENT_SESSIONS") 2>/dev/null)
    fi
    
    # Archive new sessions
    if [ -n "$NEW_SESSIONS" ]; then
        for SESSION_FILE in $NEW_SESSIONS; do
            BASENAME=$(basename "$SESSION_FILE")
            ARCHIVE_NAME="${SESSION_ID}_${BASENAME}"
            cp "$SESSION_FILE" "$RAW_DIR/$ARCHIVE_NAME"
            echo "[$SESSION_ID] ARCHIVED: $ARCHIVE_NAME" >> "$SESSIONS_LOG"
        done
    else
        echo "[$SESSION_ID] NO_SESSION_FILE" >> "$SESSIONS_LOG"
    fi
    
    # Record session end
    {
        echo "[$SESSION_ID] END $(date -Iseconds) exit=$EXIT_CODE"
        echo ""
    } >> "$SESSIONS_LOG"
    
    return $EXIT_CODE
}

# Run in async mode or synchronous mode
if [ "$ASYNC_MODE" = true ]; then
    # ASYNC MODE: Must return to caller within seconds, before graft's 30s timeout.
    # We use screen -dmS to fully detach immediately.
    
    # Create status/task files (fast, do this before detaching)
    echo "running" > "$RESULTS_DIR/$SESSION_ID.status"
    echo "$TASK_DESC" > "$RESULTS_DIR/$SESSION_ID.task"
    echo "$PROMPT" > "$RESULTS_DIR/$SESSION_ID.prompt"
    
    # Record in sessions log
    echo "[$SESSION_ID] ASYNC_STARTED $(date -Iseconds)" >> "$SESSIONS_LOG"
    
    # Create a runner script for screen to execute
    RUNNER="$RESULTS_DIR/$SESSION_ID.runner.sh"
    CURRENT_DIR="$(pwd)"
    cat > "$RUNNER" << RUNNEREOF
#!/bin/bash
cd "$CURRENT_DIR"
export HOME="$HOME"
unset ANTHROPIC_API_KEY

# Read prompt from file (handles multi-line and special characters safely)
PROMPT_FILE="$RESULTS_DIR/$SESSION_ID.prompt"

# Run Claude Code non-interactively
claude --print --dangerously-skip-permissions --output-format json "\$(cat "\$PROMPT_FILE")" > "$RESULTS_DIR/$SESSION_ID.out" 2>&1
EXIT_CODE=\$?

# Update status
if [ \$EXIT_CODE -eq 0 ]; then
    echo "complete" > "$RESULTS_DIR/$SESSION_ID.status"
else
    echo "failed:\$EXIT_CODE" > "$RESULTS_DIR/$SESSION_ID.status"
fi

# Log completion
echo "[$SESSION_ID] END \$(date -Iseconds) exit=\$EXIT_CODE" >> "$SESSIONS_LOG"

# Archive any new session files
PROJECT_DIR_MANGLED=\$(echo "$CURRENT_DIR" | sed 's|^/||; s|/|-|g')
if [ -z "\$PROJECT_DIR_MANGLED" ]; then PROJECT_DIR_MANGLED="-"; fi
CLAUDE_PROJECT_DIR="\$HOME/.claude/projects/-\$PROJECT_DIR_MANGLED"
if [ -d "\$CLAUDE_PROJECT_DIR" ]; then
    for f in "\$CLAUDE_PROJECT_DIR"/*.jsonl; do
        [ -f "\$f" ] && cp "\$f" "$RAW_DIR/${SESSION_ID}_\$(basename "\$f")" 2>/dev/null
    done
fi
RUNNEREOF
    chmod +x "$RUNNER"
    
    # Launch with screen - returns IMMEDIATELY
    screen -dmS "claude-$SESSION_ID" "$RUNNER"
    
    echo "Started async task: $SESSION_ID"
    echo "Check status: claude-sub --status $SESSION_ID"
    echo "Get result:   claude-sub --result $SESSION_ID"
    exit 0
else
    # Synchronous mode - just run it directly
    run_claude
    exit $?
fi
